const LOCATIONS = `80 95
64 78
48 70
23 25
77 82
58 63
17 65
86 90
78 100
15 50
33 100
24 25
83 90
39 55
71 87
26 29
85 100
78 91
5 81
74 97
80 97
75 79
38 42
1 47
18 68
75 86
70 100
15 28
100 100
11 12
39 100
84 89
36 81
39 40
86 86
16 44
75 93
67 68
99 100
6 24
99 99
57 91
30 75
37 77
55 57
14 58
54 56
39 68
27 32
1 100
40 89
22 53
54 59
81 83
6 50
92 95
95 100
11 67
75 87
79 93
89 100
5 17
14 26
80 91
36 41
81 83
51 72
88 88
26 65
36 54
81 81
53 79
52 86
57 71
98 99
41 45
12 29
75 89
72 72
63 71
63 82
83 84
24 29
56 64
25 41
24 74
29 42
29 30
67 71
83 87
94 94
21 23
49 68
84 88
82 88
25 30
1 71
30 57
56 61
81 88
70 90
74 84
21 25
70 95
57 87
7 99
7 24
29 31
54 100
12 31
42 54
88 90
66 67
2 84
76 98
95 100
41 41
83 92
64 97
84 85
39 82
89 90
90 95
29 29
35 88
70 70
57 61
27 31
50 53
11 12
88 90
83 86
44 69
100 100
28 59
88 90
49 53
18 49
77 85
99 100
78 81
68 74
7 32
66 67
66 71
83 93
77 92
3 86
18 43
16 16
93 94
98 98
75 75
72 77
38 41
87 96
92 100
79 97
73 89
71 95
69 71
68 73
80 89
34 70
52 52
31 34
69 69
98 99
29 37
89 100
21 66
40 85
4 33
1 79
48 54
15 93
51 90
34 34
16 40
4 7
14 60
78 99
69 92
36 79
47 79
84 89
18 19
29 57
83 88
75 96
100 100
16 54
38 100
57 63
29 33
12 66
76 99
38 96
28 83
75 77
76 79
30 54
15 83
28 52
72 72
70 98
45 66
95 98
29 30
36 41
99 99
96 96
76 85
81 85
94 98
30 34
67 77
72 73
4 58
16 25
12 35
77 90
21 22
14 14
34 93
29 33
4 55
30 31
91 94
86 99
22 23
12 53
32 91
32 33
50 62
1 100
10 11
68 80
10 95
25 64
97 98
68 71
75 76
33 35
28 91
30 33
47 48
69 72
37 64
79 79
29 36
80 95
23 33
97 97
71 94
71 86
64 95
49 53
69 69
28 60
27 31
70 98
10 35
74 82
77 91
33 80
92 100
36 72
72 72
85 98
41 42
64 83
70 74
24 40
69 80
66 66
21 22
79 83
29 67
42 74
35 37
31 34
51 94
89 95
16 17
83 88
99 99
8 68
54 76
1 100
24 72
53 95
48 53
64 67
72 90
55 95
29 30
81 82
47 65
13 52
79 97
17 78
51 54
69 91
26 29
57 67
60 94
20 68
22 27
41 46
22 49
80 84
69 72
18 22
43 80
45 53
40 57
60 82
29 41
39 82
88 91
4 75
89 100
84 88
55 97
1 6
13 14
49 54
18 19
91 91
75 76
77 84
68 99
78 96
28 68
33 37
38 80
17 17
36 95
31 37
71 72
6 55
63 83
17 34
1 13
82 97
47 99
89 99
65 89
8 92
70 73
31 33
75 98
86 90
37 88
88 100
47 71
37 60
75 94
69 70
73 76
22 99
99 100
53 74
97 99
8 8
7 15
29 49
86 94
62 69
21 91
27 71
21 74
73 76
56 56
8 53
18 60
98 99
8 29
100 100
23 79
44 93
7 9
91 94
9 87
27 99
55 60
26 85
56 83
50 51
39 44
92 92
32 85
95 100
68 73
70 80
58 68
44 52
16 25
64 89
33 99
14 80
93 94
64 94
41 72
39 43
34 42
25 25
6 74
20 70
75 90
69 73
93 95
97 97
28 52
93 98
73 100
5 7
63 68
35 83
61 98
86 92
5 86
95 97
26 28
29 30
31 90
90 95
15 70
17 20
79 81
58 89
67 67
83 87
28 82
88 88
77 80
89 98
62 66
3 72
1 97
56 90
52 55
81 93
5 7
93 96
24 69
83 96
32 79
69 78
77 90
55 76
85 86
85 87
82 83
8 26
94 100
9 63
19 50
60 79
33 76
15 90
78 99
14 86
7 60
64 84
61 95
41 70
44 46
74 92
12 48
56 92
47 54
23 49
56 60
23 89
54 54
86 93
44 46
74 79
98 99
72 92
49 50
42 75
52 93
4 31
36 74
4 20
72 72
2 71
57 75
74 88
64 74
59 79
43 80
74 77
89 99
76 84
41 82
11 13
94 95
10 96
2 3
17 99
53 84
3 30
75 78
83 91
75 88
17 65
82 100
56 57
48 76
6 60
88 97
57 60
85 95
53 94
70 71
81 94
22 72
13 44
80 90
15 50
33 42
26 35
28 31
77 85
30 79
28 76
54 56
71 80
82 88
9 47
87 98
100 100
91 93
75 98
27 39
94 98
22 84
24 25
11 61
5 66
46 84
86 100
34 39
95 97
88 90
11 89
49 69
5 8
82 85
63 78
68 84
55 75
73 74
73 77
25 39
40 45
6 11
68 92
16 20
57 80
81 98
32 71
25 86
64 69
49 54
23 90
94 96
30 91
96 96
88 89
41 68
18 87
63 85
99 99
8 70
100 100
90 100
88 99
78 86
1 68
58 59
69 85
88 98
63 97
1 41
42 84
91 92
45 60
15 36
80 85
68 90
27 70
66 67
59 97
8 78
50 85
56 64
42 55
45 88
12 75
57 95
12 12
13 92
1 5
46 78
29 77
75 79
73 79
70 90
100 100
96 96
63 67
73 74
72 75
94 94
25 83
77 86
19 26
5 35
13 53
87 93
17 52
84 90
65 91
16 46
61 72
25 81
31 81
22 58
19 64
77 83
27 67
21 47
22 24
92 97
66 67
74 74
92 93
96 97
24 53
81 82
17 95
91 98
69 79
88 90
71 96
98 99
12 75
29 32
99 99
17 20
82 99
3 40
65 66
12 94
58 71
49 52
27 40
85 91
23 23
64 88
52 93
67 88
96 99
92 92
38 86
24 43
50 66
59 83
8 82
54 85
6 74
47 97
78 99
65 66
14 77
43 75
62 69
66 67
48 61
53 66
92 96
49 52
52 81
30 60
74 79
33 56
81 97
45 94
6 50
7 96
13 16
39 55
19 21
66 70
25 58
75 91
57 57
81 83
33 68
61 83
90 90
14 49
13 17
60 98
85 86
86 92
17 30
40 91
94 94
18 89
25 27
83 94
35 59
4 17
69 72
6 86
58 99
20 39
89 96
80 98
94 97
51 67
47 81
2 66
11 35
38 60
36 69
6 97
10 73
79 96
15 45
24 28
85 86
2 3
24 43
63 63
40 80
81 93
31 56
44 50
47 68
93 97
40 95
93 95
26 62
14 26
34 50
57 86
68 70
9 11
58 61
26 75
44 98
90 99
59 61
39 43
80 84
10 92
1 19
60 67
16 76
97 97
70 72
84 84
71 99
1 33
4 23
81 89
50 68
78 90
90 100
96 100
84 100
48 67
33 45
85 97
93 99
51 53
58 70
69 76
48 55
72 81
89 95
50 100
87 87
78 86
34 34
45 53
23 24
68 87
39 57
15 46
59 78
6 8
28 28
56 64
31 92
81 86
32 64
42 65
96 99
82 90
88 90
24 34
70 74
94 94
58 79
8 12
20 35
90 90
79 81
58 60
36 74
25 76
96 96
87 89
86 87
22 92
61 79
36 37
39 90
100 100
95 100
54 54
70 71
18 66
65 74
65 73
76 95
86 87
22 72
70 73
4 69
16 100
27 88
49 51
73 98
69 75
50 96
52 68
40 85
19 49
100 100
9 89
98 99
99 99
17 21
100 100
8 86
2 89
93 98
86 97
53 89
32 34
86 93
41 48
22 56
65 93
4 6
39 81
69 76
7 85
15 27
25 99
82 83
20 80
42 68
74 92
18 24
17 84
72 73
1 91
80 81
57 85
68 72
63 65
96 98
11 54
84 100
100 100
20 92
71 79
29 34
40 53
3 99
24 78
40 84
48 82
67 80
3 56
33 86
17 96
72 97
19 21
80 88
99 100
27 28
92 92
40 50
40 58
29 39
92 95
68 81
22 46
33 38
42 77
27 56
83 86
33 77
17 28
99 100
72 74
36 71
17 99
36 56
37 65
52 75
34 59
57 67
100 100
40 40
57 84
63 68
39 80
44 57
49 69
4 94
59 83
80 85
63 97
94 99
22 58
1 5
50 69
75 78
32 62
78 82
38 59
84 88
52 98
64 93
73 90
53 98
63 82
86 94
4 47
82 92
12 16
77 97
83 97
98 100
8 45
92 97
43 46
70 95
88 89
69 75
47 72
10 89
1 74
90 100
79 81
5 30
24 27
11 77
64 100
14 100
83 94
67 69
63 68
33 96
55 99
7 47
23 45
21 22
38 40
82 94
64 67
9 81
22 95
7 88
86 98
77 94
73 75
27 30
97 97
96 97
33 84
76 78
54 64
63 83
59 84
26 80
60 63
3 59`;

let EXPECTED = `56
21
462
1
4
4
2496144
1
330
48620
637618393
1
6
70
56
2
28
40
239974276
660
84
2
1
490314
5200300
20
3003
40
1
1
206253075
3
1352078
1
1
3432
126
2
1
36
1
19448
1293292
167960
1
705432
1
6435
3
943170365
5200300
12870
2
1
319770
2
1
37442160
20
35
10
1
20
20
2
1
504
1
184756
126
1
1716
24310
35
1
1
112
35
1
4
168
2
3
6
56
5200300
30
1
2
2
1
1
252
1
3
4
319959386
3432
2
6
210
10
2
1287
5005
953079104
36
1
817190
210
15
1
1
77445985
330
1
1
10
12376
2
705432
2
3
1
17383860
1
1
2
2
1
1
2
1716
1
12870
1
2
12870
6
1
2
3
715
1
3
10
70
661925378
1716
1
2
1
1
2
1
8
1
84
56
495
1
3
10
48620
1
2
1
1
6
10
1352078
1410864
2002
711260731
3
359143556
167960
1
792
1
1352078
330
660
705432
12870
3
2
3432
3
420
1
92378
206253075
3
2
20058300
660
67863915
37442160
1
2
924
203961416
792
1
2002
462
1
1
2
1
1
10
2
1
2
5
1
13037895
12
792
35
1
1
145422675
2
5311735
2
2
12
2
293930
145422675
2
15
943170365
1
15
394237151
184756
1
2
2
1
530365050
2
2
2
3432
1
6
56
10
1
660
56
8008
2
1
12870
2
2002
1287
6
35
2704156
1
48620
1
21
2
210
1
70
15
1
1
2
92378
12870
1
2
646646
3
2
3
1
119759850
462
943170365
2704156
293930
4
2
84
167960
1
2
126
167960
84
300540195
2
330
2
10
19448
2704156
2
3
3432
2
2
1
97240
6
112
330
15
705432
2
796297179
10
1
293930
2
1
4
2
1
2
6
6006
126
184756
2
352716
1
135727830
3
1
3268760
210
126
1
42
7726160
5
792
697118579
2
1
660
1
9657700
6
924
792
252
2
2
562286361
1
462
1
1
1
252
4
4
537567622
705432
20058300
2
1
817190
352716
1
240
1
40116600
5200300
1
2
21117453
567902525
2
155117520
3432
2
4
1
20058300
1
3
10
10
6
12
1287
818809200
37158313
2
5005
12870
2
4
1
391975633
5200300
70
1
1
1
792
2
1430
1
3
2496144
37128
3
584479393
1
1
1
145422675
3
40116600
2
1
10010
1
2
17383860
1
2
8
1
319959386
847815693
19448
2
20
1
2
1352078
30
2704156
8
35
462
2
1
2
84
1
17383860
12870
210
705432
810737203
330
597496544
17383860
210
12376
6006
1
126
43758
43758
6
1716
1
166803103
1
6
1
4
1
210
2
25740
335920
1001
92378
8
1
319959386
84
35
5
210
97240
2
5
6
369512
1
1
359043950
1
112639186
12870
572
2
6
35
2496144
36
1
3432
17383860
8
2
10
335920
2
35
5200300
11440
10
48620
10
12
2
6
5200300
2496144
1
8
3
50388
10
1
1
660
15
1
300540195
1
5200300
206253075
92378
7
3
1
1
21117453
252
1
2
42
56
210
1
1
35
3
1
792
2
792
84
184756
300540195
3
4
333606206
1
290845350
1
2
3003
407922832
330
1
265182525
1
5
10
6
391975633
2
56
5
12376
38760
352716
2
56
462
4
330
705432
1
50388
247943139
48620
6
30
646646
471435600
75582
1
380261009
1
11440
2496144
2
3
210
1
1
1
1
1
1
77558760
12
6
3003
167960
3
48620
3
1287
6435
15
40116600
5200300
43758
1352078
3
184756
1716
1
2
1
1
2
1
6864
2
359143556
4
10
1
990
1
471435600
2
1
2
56
17136
2
112639186
35
2
30
3
1
495
335920
330
1
1
2496144
252
70
792
875774586
12870
391975633
4457400
330
2
530365050
12870
4
1
21
35
1
2
6435
6435
4
924
56
4992288
319770
61379515
1
70
1
2
24310
70
1
1
48620
330
1
48620
1
50388
2
3
40
10400600
1
597496544
1
20
924
2
2
732378184
155040
252
6
84
1
70
24310
347373600
792
462
25740
768965863
471435600
112
6435
1
2
1
252
1
184756
20
1716
3
462
1
37442160
1
43758
20
70
6006
1
1
2
4992288
17383860
5
1
2
2
112639186
9
6
145422675
1
1
1
1001
4368
18
6
126
20
5
1
28
252
20
15
1
1
20
4
6
10
3
3268760
1
6
1
6
1
210
126
12870
210
1
1
6
290845350
4
12870
660
1
4
1
10
1
1
420
1
70
1
1
1
92378
10400600
1
1
1
537567622
84
2
9657700
1
1
1
2
2704156
8
4
252
1
5200300
2
694747200
697118579
265182525
1
990
1
1144066
70
1410864
6435
1
732378184
1
1
2
1
21117453
343291622
2
10
43758
1
6
6
24310
3003
1
352716
4
21117453
20
875774586
2
145422675
1287
126
3
333606206
1
884482935
2
3003
2
1
1
587860
28
1
597496544
4
4
40
836949941
20058300
705432
24310
30
10623470
20058300
718287112
990
1
4
1
2
1
10
126
10
2
35
924
4
48620
6864
2
646646
20
1
1
48620
112639186
252
3003
792
1716
10
1
1
3003
3
352716
30
252
884482935
792
4
12376
1
43758
1
252
2
6435
2
462
1
817190
5005
112
994840
168
4
232560
10
1
210
21
1
63648
2
2
1287
2
1
1848
42234906
592594351
5
1
440
1
818809200
18564
359043950
20
1
3
530365050
497420
77520
462
1
1
15
2
307872061
194993081
584479393
6
126
1
2
1
1
10400600
1
10
210
1584
20058300
2
21474180`;



function getMaxLength(letters) {
  let isOdd = false;
  let result = letters.reduce((total, [_, i]) => {
    if (i % 2 === 0) {
      total += 1;
    } else {
      isOdd = true;
    }
    return total;
  }, 0);
  if (isOdd) {
    result ++;
  }
  return result;
}

// function getCombinations(letters) {
//   let isOdd = false;
//   let combinations = [];
//   const evenLetters = letters.reduce((total, [letter, i]) => {
//     if (i >= 2) {
//       let j = parseInt(i / 2);
//       total.push({
//         letter,
//         factorial: factorial(j),
//       });
//       if (i % 2 > 0) {
//         isOdd = true;
//       }
//       // total += 1;
//     } else {
//       isOdd = true;
//     }
//     return total;
//   }, []);

//   const num = evenLetters.length;
//   const factorialTotal = evenLetters.reduce((total, letter) => {
//     total = total * letter.factorial;
//     return total;
//   }, 1);

//   const result = factorial(num) / (factorialTotal);

//   let numOddLetters = 1;
//   if (isOdd) {

//     const oddLetters =  letters
//       .filter(([_, i]) => i%2 > 0)
//       .map(([l]) => l);
//     numOddLetters = oddLetters.length;
//   }
//   if (result === 0 && isOdd) {
//     return numOddLetters;
//   }
//   return numOddLetters * result;
// }

const bigNumber = require('bignumber.js');
const hashFactorial = new Map();
const M = 1000000007;
const modInverses = new Map();
const gcdHash = new Map();

function modInverse(a, m) {
  const g = gcdCheck(a.toNumber(), m) 
  if (g !== 1) {
    console.log("Inverse doesn't exist") 
  } else {
    if (modInverses.get(a)) {
      return modInverses.get(a);
    }
    const MMI = power(a, m - 2, m);
    modInverses.set(a, MMI);
    return MMI;
  }
}
      
// To compute x^y under modulo m 
function power(x, y, m) {
  // console.log(x, y, m);
  if (y === 0)  {
    return 1; 
  }

  let p = power(x, parseInt(y / 2), m) % m; 
  // const pp = (p.toExponential() * p.toExponential()).toExponential();
  // console.log(p * p, (p*p) % m);
  const bigP = new bigNumber(p);
  const bigPP = bigP.multipliedBy(bigP);
  // console.log(BigInt(p)*BigInt(p), (BigInt(p) * BigInt(p)) % BigInt(m));
  p = bigPP.modulo(m).toNumber();
  // p = Number((BigInt(p) * BigInt(p)) % BigInt(m));
  // p = Number((Number(p) * Number(p)) % Number(m)); 

  if (y % 2 == 0)  {
    return p; 
    // return parseInt(p); 
  } else {
    return bigNumber(x).multipliedBy(p).modulo(m); 
    // return parseInt((x * p) % m); 
  }    
}

function gcdCheck(a,b) {
  if (gcdHash.get(a)) {
    return gcdHash.get(a);
  }
  const g = gcd(a, b);
  gcdHash.set(a, g);
  return g;
}

function gcd(a, b) { 
  if (a == 0) {
    return b; 
  }
  return gcd(b % a, a); 
} 

  
function factorial(n) {
  if (hashFactorial.get(n)) {
    return hashFactorial.get(n);
  }
  let result = bigNumber(1);
  for (let i = 1; i <= n; i++) {
    result = result.multipliedBy(i).modulo(M);
    // result = (result*i) % M;
  }
  hashFactorial.set(n, result);
  return result;
}

let chars = ['a', 'b','c','d','e','f','g','h','i', 'j','k','l','m','n',
'o','p','q','r','s','t','u','v','w','x','y','z'];

function getCombinations(cnt, l, r) {
  const hash = {}
  // const evens = {}
  let odds = 0;

  // for (let i = l; i < r; i++) {
  //   const letter = str[i];
  //   if (hash[letter]) {
  //     hash[letter] += 1;
  //     if (hash[letter] % 2 > 0) {
  //       odds++;
  //     } else {
  //       evens[letter] = hash[letter] / 2;
  //       odds--;
  //     }
  //   } else {
  //     hash[letter] = 1;
  //     odds++;
  //   }
  // }
  let factorialTotal = new bigNumber(1);
  let evens = 0;
  // let newChars = [];
  // console.log(chars);
  for (let i=0; i < chars.length; i++) {
    const num = findCharFreq(l, r - 1, chars[i], cnt);
    if (num > 0) {
      // newChars.push(chars[i]);
      if (num % 2 > 0) {
        odds++;
        if (num > 2) {
          evens += (num - 1) / 2;
          factorialTotal = factorialTotal.multipliedBy(factorial((num - 1) / 2));  
        }
      } else {
        evens += num / 2;
        factorialTotal = factorialTotal.multipliedBy(factorial(num / 2));
      }
    } 
  }
  // chars = newChars;
  const numOfEvens = evens;
  
  // const { factorialTotal, numOfEvens } = Object.values(evens).reduce((total, n) => {
  //   total.factorialTotal = total.factorialTotal.multipliedBy(factorial(n));
  //   // total.factorialTotal = total.factorialTotal * factorial(n)
  //   total.numOfEvens += n;
  //   return total;
  // }, { factorialTotal: new bigNumber(1), numOfEvens: 0 });

  let result = factorial(numOfEvens)
    .multipliedBy(modInverse(factorialTotal, M))
    .modulo(M);

  if (result.toNumber() === 0 && odds > 0) {
    return odds;
  } else if (odds > 0) {
    result = result.modulo(M);
    return result
      .multipliedBy(odds % M)
      .modulo(M)
      .toNumber();
    // return odds * result;
  } else {
    return result.toNumber();
  }
}

function getHashMap(str) {
  const hashMap =  str
  .split("")
  .reduce((total, s) => {
    if (!!total[s]) {
      total[s] += 1;
    } else {
      total[s] = 1;
    }
    return total;
  }, {});
  return Object.entries(hashMap); //.sort(([_,a2], [__,b2]) => b2 - a2);
}

function answerQuery(l, r, cnt) {
  return getCombinations(cnt, l - 1, r);
}

function preProcess(str) {
  const cnt = [...Array(str.length).keys()].map(s => 
    [...Array(26).keys()].map(s => 0)
  )
  // console.log(cnt);
  // const cnt = [];
  for (let i = 0; i < str.length; i++) {
    if (!cnt[i]) {
      cnt[i] = [];
    }
    const arr = cnt[i];
    if (!arr[str.charCodeAt(i) - 'a'.charCodeAt(0)]) {
      arr[str.charCodeAt(i) - 'a'.charCodeAt(0)] = 0;
    }
    arr[str.charCodeAt(i) - 'a'.charCodeAt(0)]++;
  }
  // console.log(cnt);

  for (let i = 1; i < str.length; i++) { 
		for (let j = 0; j < 26; j++) {
			cnt[i][j] += cnt[i - 1][j]; 
    } 
  }
  return cnt; 
}

function findCharFreq(l, r, c, cnt) { 
	// Return occurrence of character 
	// from 0 to r minus its 
  // occurrence from 0 to l 
  const posC = c.charCodeAt(0) - 'a'.charCodeAt(0);
  if (l === 0) {
    // console.log(cnt, r, cnt[r]);
    return cnt[r][posC];
  }
  return cnt[r][posC] - cnt[l - 1][posC];
  // return arr[posC]; 
} 



const locations = LOCATIONS
.split(/(\r\n|\n|\r)/gm)
.filter(s => !s.match(/(\r\n|\n|\r)/))
.map(s => s.split(" ").map(p => Number(p)));

EXPECTED = EXPECTED
.split(/(\r\n|\n|\r)/gm)
.filter(s => !s.match(/(\r\n|\n|\r)/))
.map(Number);
 
// console.log(modInverse(3, 1000000007));

// const str = 'week';
const str = 'saaaaaaaaaaaaaaasasaaasssssaaasassaasaaaassssaassasaassssasssaaasaasasaaaaasassasasasaaasasasaaaaaaa';
// const chars = [...new Set([...str])];
const cnt = preProcess(str);
// console.log(chars, cnt);
// const options = answerQuery(2, 3, chars, cnt);
// console.log(options);

console.time("PAL");
for (let q = 0; q < 2; q ++) {
  locations.forEach(([l, r], i) => {
    // console.log(l, r);
  const options =    answerQuery(l, r, cnt);
    if (EXPECTED[i] !== options) {
      console.log(`FAIL ${l}, ${r}, ${options}, ${EXPECTED[i]}`);
      return null;
    } else {
      // if (options.toString().length > 10) {
        // console.log(`SUCCESSED ${l}, ${r}, ${options}, ${EXPECTED[i]}`);
      // }
    }
  });
}
console.timeEnd("PAL");



// // const a = initialize('aaav');
// // const options = getCombinations(a);
// const options = answerQuery(33, 100, 'saaaaaaaaaaaaaaasasaaasssssaaasassaasaaaassssaassasaassssasssaaasaasasaaaaasassasasasaaasasasaaaaaaa');
// // // // // const options = answerQuery(3, 5, 'wuhmbspjnfviogqzldrcxtaeyk')
// // console.log(options);

/*
qfq
qgf
fgq
fqg
gfq
gqf

aab

3! - (1*3) = 6 -3

aab
baa
aba


aabc
====

1 aabc
2 aacb
3 abac
4 acab
5 abca
6 acba
7 baac
8 baca
9 bcaa
10 caab
11 caba
12 cbaa



4! 
aaab
====
1 aaab
2 aaba
3 abaa
4 baaa

24 / 3! (6)









1 abcd
2 abdc
3 adbc
4 adcb
5 acdb
6 acbd


7 bacd
8 badc
9 bcad
10 ba






1 qfgagfq
qfgegfq
2 qgfafgq
qgfefgq

3 fgqaqgf
fgqeqgf
4 fqgagqf
fqgegqf

n! 


Generation of palindrome can be done by following steps,

First we need to check whether letters of string can 
make a palindrome or not, if not then return.

After above checking we can make half part of first palindrome string 
(lexicographically smallest) by taking half frequency of each 
letter of the given string.

Now traverse through all possible permutation of this half string
and each time add reverse of this part at the end and 
add odd frequency character in mid between if string is of 
odd length, for making the palindrome.

for (let i = l; i <= r; i ++) {
  const letter = str[i];
  const letterObj = hashMap[letter];
  const { positions } = letterObj

}

*/